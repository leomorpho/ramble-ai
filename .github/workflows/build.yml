name: Build and Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build:
    strategy:
      matrix:
        platform: [macos-latest] # windows-latest temporarily disabled
        go-version: [1.22]
    runs-on: ${{ matrix.platform }}
    environment: Official Build
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
          cache: false
      
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
      
      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9
      
      - name: Install Wails
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest
        timeout-minutes: 10
      
      - name: Install frontend dependencies
        run: |
          cd frontend
          pnpm install --frozen-lockfile
        timeout-minutes: 10
      
      - name: Download FFmpeg binaries
        run: |
          mkdir -p binaries/static
          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            curl -L -o binaries/static/ffmpeg-macos.zip https://github.com/ffbinaries/ffbinaries-prebuilt/releases/download/v6.1/ffmpeg-6.1-macos-64.zip
            cd binaries/static && unzip -o ffmpeg-macos.zip && mv ffmpeg ffmpeg-darwin-amd64
            rm -f ffmpeg-macos.zip
          else
            curl -L -o binaries/static/ffmpeg-windows.zip https://github.com/ffbinaries/ffbinaries-prebuilt/releases/download/v6.1/ffmpeg-6.1-win-64.zip
            cd binaries/static && unzip -o ffmpeg-windows.zip && mv ffmpeg.exe ffmpeg-windows-amd64.exe
            rm -f ffmpeg-windows.zip
          fi
        shell: bash
      
      - name: Verify FFmpeg binaries before build
        run: |
          echo "Checking FFmpeg binaries before build:"
          ls -la binaries/static/
          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            if [ ! -f "binaries/static/ffmpeg-darwin-amd64" ]; then
              echo "‚ùå ERROR: ffmpeg-darwin-amd64 binary missing!"
              exit 1
            else
              echo "‚úÖ ffmpeg-darwin-amd64 found"
              file binaries/static/ffmpeg-darwin-amd64
            fi
          else
            if [ ! -f "binaries/static/ffmpeg-windows-amd64.exe" ]; then
              echo "‚ùå ERROR: ffmpeg-windows-amd64.exe binary missing!"
              exit 1
            else
              echo "‚úÖ ffmpeg-windows-amd64.exe found"
              file binaries/static/ffmpeg-windows-amd64.exe
            fi
          fi
        shell: bash
      
      - name: Verify embed files before build
        run: |
          echo "Verifying embed files are accessible before build..."
          echo "Current working directory: $(pwd)"
          echo "Contents of binaries/static/:"
          ls -la binaries/static/ || echo "‚ùå binaries/static/ directory not found"
          
          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            if [ -f "binaries/static/ffmpeg-darwin-amd64" ]; then
              echo "‚úÖ Found binaries/static/ffmpeg-darwin-amd64"
              file binaries/static/ffmpeg-darwin-amd64
              echo "Size: $(stat -f%z binaries/static/ffmpeg-darwin-amd64) bytes"
            else
              echo "‚ùå ERROR: binaries/static/ffmpeg-darwin-amd64 not found"
              echo "This will cause Go embed to fail!"
              exit 1
            fi
          fi
        shell: bash
        
      - name: Build Wails app
        run: |
          echo "Building with production tags..."
          echo "Current platform: ${{ matrix.platform }}"
          echo "Build tags will include: production"
          echo "Expected to embed: binaries/static/ffmpeg-darwin-amd64"
          
          echo "Starting Wails build with verbose output..."
          wails build -tags production -v 2 || {
            echo "‚ùå Wails build failed!"
            echo "Checking if it's an embed issue..."
            echo "Go build test with production tags:"
            go build -tags production -v . || echo "Go build also failed"
            exit 1
          }
          
          echo "‚úÖ Wails build completed successfully"
      
      - name: Bundle FFmpeg binary in app package
        run: |
          echo "Copying FFmpeg binary to app bundle..."
          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            if [ -f "binaries/static/ffmpeg-darwin-amd64" ] && [ -d "build/bin/RambleAI.app/Contents/MacOS" ]; then
              cp binaries/static/ffmpeg-darwin-amd64 build/bin/RambleAI.app/Contents/MacOS/ffmpeg
              chmod +x build/bin/RambleAI.app/Contents/MacOS/ffmpeg
              echo "‚úÖ FFmpeg binary bundled successfully"
              ls -lh build/bin/RambleAI.app/Contents/MacOS/ffmpeg
            else
              echo "‚ùå ERROR: Cannot bundle FFmpeg - source binary or destination directory missing"
              echo "Source exists: $(test -f binaries/static/ffmpeg-darwin-amd64 && echo yes || echo no)"
              echo "Destination exists: $(test -d build/bin/RambleAI.app/Contents/MacOS && echo yes || echo no)"
              exit 1
            fi
          fi
        shell: bash
      
      - name: Verify FFmpeg bundling and embedding in built app
        run: |
          echo "Checking FFmpeg bundling and embedding in the built app..."
          if [[ "${{ matrix.platform }}" == "macos-latest" ]]; then
            if [ -f "build/bin/RambleAI.app/Contents/MacOS/RambleAI" ]; then
              echo "‚úÖ Built binary found: build/bin/RambleAI.app/Contents/MacOS/RambleAI"
              
              # Verify FFmpeg was bundled correctly
              if [ -f "build/bin/RambleAI.app/Contents/MacOS/ffmpeg" ]; then
                echo "‚úÖ Bundled FFmpeg binary found: build/bin/RambleAI.app/Contents/MacOS/ffmpeg"
                ls -lh build/bin/RambleAI.app/Contents/MacOS/ffmpeg
                
                # Test if it's executable
                if [ -x "build/bin/RambleAI.app/Contents/MacOS/ffmpeg" ]; then
                  echo "‚úÖ Bundled FFmpeg is executable"
                  # Test FFmpeg version
                  build/bin/RambleAI.app/Contents/MacOS/ffmpeg -version | head -1
                  echo "‚úÖ Bundled FFmpeg is working"
                else
                  echo "‚ùå ERROR: Bundled FFmpeg is not executable"
                  exit 1
                fi
                
                # Note: FFmpeg binary will be signed later in the signing step
                echo "üìù Note: FFmpeg binary will be code signed before app notarization"
              else
                echo "‚ùå ERROR: Bundled FFmpeg binary not found - this should have been copied by previous step"
                exit 1
              fi
              
              # Check main binary size - embedded FFmpeg should make it significantly larger
              ls -lh build/bin/RambleAI.app/Contents/MacOS/RambleAI
              BINARY_SIZE=$(stat -f%z build/bin/RambleAI.app/Contents/MacOS/RambleAI)
              echo "Main binary size: $BINARY_SIZE bytes"
              # FFmpeg binary is ~80MB, so if the total is less than 50MB, embedding likely failed
              if [ $BINARY_SIZE -lt 52428800 ]; then
                echo "‚ö†Ô∏è  WARNING: Main binary size is small, embedded FFmpeg may not be available"
              else
                echo "‚úÖ Main binary size looks good for embedded FFmpeg"
              fi
              
              # Check for embedded FFmpeg signature in main binary
              echo "Checking for embedded FFmpeg signature in main binary..."
              if strings build/bin/RambleAI.app/Contents/MacOS/RambleAI | grep -q "FFmpeg"; then
                echo "‚úÖ Found FFmpeg signature in main binary (embedded backup available)"
              else
                echo "‚ö†Ô∏è  WARNING: No FFmpeg signature found in main binary"
              fi
            else
              echo "‚ùå ERROR: Built binary not found!"
              exit 1
            fi
          fi
        shell: bash
      
      - name: Clean up after build to save space
        run: |
          echo "Disk space before cleanup:"
          df -h
          
          # Extremely aggressive cleanup to free maximum space
          rm -rf binaries/static
          rm -rf frontend/node_modules
          rm -rf frontend/.svelte-kit
          rm -rf frontend/build
          go clean -cache -modcache -testcache
          
          # Clean Go workspace
          rm -rf ~/go/pkg/mod
          rm -rf ~/.cache/go-build
          
          # Clean any temporary build files
          find . -name "*.tmp" -delete 2>/dev/null || true
          find . -name "*.temp" -delete 2>/dev/null || true
          find . -name "*.log" -delete 2>/dev/null || true
          
          # Clean homebrew cache
          brew cleanup --prune=all 2>/dev/null || true
          
          echo "Disk space after cleanup:"
          df -h
        shell: bash
      
      # macOS signing with gon - following Wails documentation approach
      - name: Install gon for macOS signing
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        run: brew install Bearer/tap/gon
      
      - name: Debug - Check required secrets
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        run: |
          echo "Checking required configuration (secrets or vars):"
          
          # Check certificate (usually a secret)
          if [ -n "${{ secrets.APPLE_DEVELOPER_CERTIFICATE_P12_BASE64 }}" ] || [ -n "${{ vars.APPLE_DEVELOPER_CERTIFICATE_P12_BASE64 }}" ]; then
            echo "‚úÖ APPLE_DEVELOPER_CERTIFICATE_P12_BASE64: found"
          else
            echo "‚ùå APPLE_DEVELOPER_CERTIFICATE_P12_BASE64: missing from both secrets and vars"
          fi
          
          # Check certificate password (usually a secret)
          if [ -n "${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}" ] || [ -n "${{ vars.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}" ]; then
            echo "‚úÖ APPLE_DEVELOPER_CERTIFICATE_PASSWORD: found"
          else
            echo "‚ùå APPLE_DEVELOPER_CERTIFICATE_PASSWORD: missing from both secrets and vars"
          fi
          
          # Check Apple ID (can be either)
          if [ -n "${{ secrets.APPLE_ID }}" ] || [ -n "${{ vars.APPLE_ID }}" ]; then
            echo "‚úÖ APPLE_ID: found"
          else
            echo "‚ùå APPLE_ID: missing from both secrets and vars"
          fi
          
          # Check Apple ID password (usually a secret)
          if [ -n "${{ secrets.APPLE_ID_PASSWORD }}" ] || [ -n "${{ vars.APPLE_ID_PASSWORD }}" ]; then
            echo "‚úÖ APPLE_ID_PASSWORD: found"
          else
            echo "‚ùå APPLE_ID_PASSWORD: missing from both secrets and vars"
          fi
          
          # Check Team ID (can be either)
          if [ -n "${{ secrets.APPLE_TEAM_ID }}" ] || [ -n "${{ vars.APPLE_TEAM_ID }}" ]; then
            echo "‚úÖ APPLE_TEAM_ID: found"
          else
            echo "‚ùå APPLE_TEAM_ID: missing from both secrets and vars"
          fi
      
      - name: Import Code-Signing Certificates for macOS
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        uses: Apple-Actions/import-codesign-certs@v1
        with:
          p12-file-base64: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_P12_BASE64 }}
          p12-password: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}
      
      - name: List available signing identities
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        run: |
          echo "Available signing identities:"
          security find-identity -v -p codesigning
          echo ""
          echo "Looking for Developer ID Application:"
          security find-identity -v -p codesigning | grep "Developer ID Application" || echo "No Developer ID Application found"
      
      - name: Create gon configuration with actual values
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        run: |
          # Get the actual Developer ID Application identity
          IDENTITY=$(security find-identity -v -p codesigning | grep "Developer ID Application" | head -1 | awk -F'"' '{print $2}')
          
          if [[ -z "$IDENTITY" ]]; then
            echo "‚ùå No Developer ID Application identity found after importing certificate"
            exit 1
          fi
          
          echo "‚úÖ Found identity: $IDENTITY"
          
          # Create gon configuration with actual values (not env variables)
          # We need gon to create a zip for notarization, then we'll fix the structure afterward
          cat > ./build/darwin/gon-sign-runtime.json << EOF
          {
            "source": ["./build/bin/RambleAI.app"],
            "bundle_id": "com.leoaudibert.ramble-ai",
            "apple_id": {
              "username": "${{ vars.APPLE_ID || secrets.APPLE_ID }}",
              "password": "${{ secrets.APPLE_ID_PASSWORD }}",
              "provider": "${{ vars.APPLE_TEAM_ID || secrets.APPLE_TEAM_ID }}"
            },
            "sign": {
              "application_identity": "$IDENTITY",
              "entitlements_file": "./build/darwin/entitlements.plist"
            },
            "zip": {
              "output_path": "./build/bin/RambleAI-notarized.zip"
            }
          }
          EOF
          echo "‚úÖ Created gon configuration with identity: $IDENTITY"
        shell: bash
      
      - name: Sign bundled FFmpeg binary separately
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        run: |
          # Get the actual Developer ID Application identity
          IDENTITY=$(security find-identity -v -p codesigning | grep "Developer ID Application" | head -1 | awk -F'"' '{print $2}')
          
          if [[ -z "$IDENTITY" ]]; then
            echo "‚ùå No Developer ID Application identity found"
            exit 1
          fi
          
          echo "‚úÖ Signing bundled FFmpeg binary with identity: $IDENTITY"
          
          # Sign the bundled FFmpeg binary first (required for app bundle signing)
          if [ -f "build/bin/RambleAI.app/Contents/MacOS/ffmpeg" ]; then
            codesign -s "$IDENTITY" -f -v --timestamp --options runtime build/bin/RambleAI.app/Contents/MacOS/ffmpeg
            echo "‚úÖ FFmpeg binary signed successfully"
            
            # Verify the signing worked
            codesign -v build/bin/RambleAI.app/Contents/MacOS/ffmpeg
            echo "‚úÖ FFmpeg binary signature verified"
          else
            echo "‚ùå ERROR: FFmpeg binary not found for signing"
            exit 1
          fi
        shell: bash

      - name: Sign and notarize macOS app with gon
        if: matrix.platform == 'macos-latest' && github.event_name != 'pull_request'
        run: |
          echo "‚úÖ Signing and notarizing macOS app with gon..."
          echo "Using runtime configuration: ./build/darwin/gon-sign-runtime.json"
          
          # Show the configuration being used (without sensitive data)
          echo "Configuration contents:"
          cat ./build/darwin/gon-sign-runtime.json | jq -r 'del(.apple_id.password)'
          
          gon -log-level=info ./build/darwin/gon-sign-runtime.json
          echo "‚úÖ App signed and notarized successfully"
          
          # Fix the zip structure - gon creates a notarized zip but structure may not be ideal for end users
          cd build/bin
          if [ -f "RambleAI-notarized.zip" ]; then
            echo "üì¶ Fixing zip structure for better user experience..."
            
            # Check what's in the gon-created zip
            echo "Original zip contents:"
            unzip -l RambleAI-notarized.zip | head -10
            
            # Extract to temp directory
            mkdir -p temp_fix
            cd temp_fix
            unzip -q ../RambleAI-notarized.zip
            
            # Find the .app bundle and create a properly structured zip
            if [ -d "RambleAI.app" ]; then
              echo "‚úÖ Found RambleAI.app at root - creating proper zip"
              ditto -ck --keepParent RambleAI.app ../RambleAI-signed.zip
            else
              # Look for Contents directory and reconstruct the .app
              if [ -d "Contents" ]; then
                echo "üîß Found Contents directory - reconstructing RambleAI.app bundle"
                mkdir -p RambleAI.app
                mv Contents RambleAI.app/
                ditto -ck --keepParent RambleAI.app ../RambleAI-signed.zip
              else
                echo "‚ùå Could not find .app or Contents directory"
                ls -la
                exit 1
              fi
            fi
            
            cd ..
            rm -rf temp_fix
            echo "‚úÖ Created properly structured RambleAI-signed.zip"
          else
            echo "‚ùå No notarized zip found"
            exit 1
          fi
        shell: bash
      
      # Skip DMG creation for now - just upload the .app bundle
      # DMG creation is failing due to disk space constraints
      # - name: Create macOS DMG
      
      # DMG and notarization disabled for now - focusing on basic signing first
      # - name: Sign macOS DMG
      # - name: Notarize macOS app
      
      # Windows build temporarily disabled
      
      - name: Package macOS app for upload
        if: matrix.platform == 'macos-latest'
        run: |
          cd build/bin
          # Check for notarized zip file
          if [ -f "RambleAI-signed.zip" ]; then
            echo "‚úÖ Found notarized zip file"
            ls -lh RambleAI-signed.zip
            
            # Verify the notarized zip contains the app bundle properly
            echo "üì¶ Contents of notarized zip (should show RambleAI.app at root):"
            unzip -l RambleAI-signed.zip | head -20
            
            # Copy the notarized zip for upload
            cp RambleAI-signed.zip RambleAI-macos.zip
            echo "‚úÖ Using notarized RambleAI-macos.zip"
          else
            echo "‚ö†Ô∏è No notarized file found, creating regular zip with ditto"
            # Use ditto to preserve .app bundle structure
            ditto -ck --keepParent RambleAI.app RambleAI-macos.zip
            echo "‚úÖ Created regular RambleAI-macos.zip with proper structure"
          fi
          
          echo "Final artifact details:"
          ls -lh RambleAI-macos.zip
          echo "Final artifact contents (first 20 lines):"
          unzip -l RambleAI-macos.zip | head -20
      
      - name: Upload artifacts macOS
        if: matrix.platform == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: RambleAI-macos
          path: build/bin/RambleAI-macos.zip
          compression-level: 0  # Don't compress again since it's already a zip
      
      # Windows artifacts disabled
      # - name: Upload artifacts Windows
      
      # Create release when pushing tags
      - name: Create Release
        if: startsWith(github.ref, 'refs/tags/') && matrix.platform == 'macos-latest'
        uses: softprops/action-gh-release@v1
        with:
          files: build/bin/RambleAI-macos.zip
          draft: true
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # Windows release disabled
      # - name: Add Windows to Release